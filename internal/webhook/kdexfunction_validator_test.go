package webhook

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	kdexv1alpha1 "kdex.dev/crds/api/v1alpha1"
	"kdex.dev/crds/linter"
)

func TestKDexFunctionValidator_ValidateCreate(t *testing.T) {
	validator := &KDexFunctionValidator[*kdexv1alpha1.KDexFunction]{}
	ctx := context.Background()

	t.Run("valid function with minimal spec", func(t *testing.T) {
		function := &kdexv1alpha1.KDexFunction{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-function",
				Namespace: "default",
			},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				HostRef: corev1.LocalObjectReference{
					Name: "test-host",
				},
				API: kdexv1alpha1.API{
					BasePath: "/v1/users",
					Paths: map[string]kdexv1alpha1.PathItem{
						"/v1/users": {
							Summary:     "User operations",
							Description: "Operations for managing users",
						},
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{
					AutoGenerated: true,
				},
			},
		}

		// Add a GET operation
		getOp := []byte(`{
			"summary": "Get users",
			"operationId": "users-get",
			"description": "Retrieve a list of users",
			"responses": {
				"200": {
					"description": "Success",
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"items": {
									"type": "object"
								}
							}
						}
					}
				}
			}
		}`)
		pathItem := function.Spec.API.Paths["/v1/users"]
		pathItem.Get = &runtime.RawExtension{Raw: getOp}
		function.Spec.API.Paths["/v1/users"] = pathItem

		warnings, err := validator.ValidateCreate(ctx, function)
		assert.NoError(t, err)
		assert.Empty(t, warnings)
	})

	t.Run("missing hostRef name", func(t *testing.T) {
		function := &kdexv1alpha1.KDexFunction{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-function",
				Namespace: "default",
			},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				HostRef: corev1.LocalObjectReference{
					Name: "",
				},
				API: kdexv1alpha1.API{
					BasePath: "/v1/users",
					Paths: map[string]kdexv1alpha1.PathItem{
						"/v1/users": {},
					},
				},
			},
		}

		warnings, err := validator.ValidateCreate(ctx, function)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "spec.hostRef.name must not be empty")
		assert.Empty(t, warnings)
	})

	t.Run("invalid basePath format", func(t *testing.T) {
		function := &kdexv1alpha1.KDexFunction{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-function",
				Namespace: "default",
			},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				HostRef: corev1.LocalObjectReference{
					Name: "test-host",
				},
				API: kdexv1alpha1.API{
					BasePath: "/invalid", // Should be /word/word
					Paths: map[string]kdexv1alpha1.PathItem{
						"/invalid": {},
					},
				},
			},
		}

		warnings, err := validator.ValidateCreate(ctx, function)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "spec.api.basePath")
		assert.Empty(t, warnings)
	})

	t.Run("path does not match pattern", func(t *testing.T) {
		function := &kdexv1alpha1.KDexFunction{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-function",
				Namespace: "default",
			},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				HostRef: corev1.LocalObjectReference{
					Name: "test-host",
				},
				API: kdexv1alpha1.API{
					BasePath: "/v1/users",
					Paths: map[string]kdexv1alpha1.PathItem{
						"/invalid": {}, // Doesn't match /word/word pattern
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{
					AutoGenerated: true,
				},
			},
		}

		warnings, err := validator.ValidateCreate(ctx, function)
		assert.Error(t, err)
		if err != nil {
			assert.Contains(t, err.Error(), "spec.api.paths")
		}
		assert.Empty(t, warnings)
	})

	t.Run("manual function missing language", func(t *testing.T) {
		function := &kdexv1alpha1.KDexFunction{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-function",
				Namespace: "default",
			},
			Spec: kdexv1alpha1.KDexFunctionSpec{
				HostRef: corev1.LocalObjectReference{
					Name: "test-host",
				},
				API: kdexv1alpha1.API{
					BasePath: "/v1/users",
					Paths: map[string]kdexv1alpha1.PathItem{
						"/v1/users": {},
					},
				},
				Metadata: kdexv1alpha1.KDexFunctionMetadata{
					AutoGenerated: false,
				},
				Function: kdexv1alpha1.KDexFunctionExec{},
			},
		}

		warnings, err := validator.ValidateCreate(ctx, function)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "spec.function.language is required")
		assert.Empty(t, warnings)
	})

}

func TestKDexFunctionValidator_ValidateOpenAPI(t *testing.T) {
	validator := &KDexFunctionValidator[*kdexv1alpha1.KDexFunction]{}

	t.Run("valid OpenAPI spec", func(t *testing.T) {
		spec := &kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.API{
				BasePath: "/v1/users",
				Paths: map[string]kdexv1alpha1.PathItem{
					"/v1/users": {
						Summary:     "User operations",
						Description: "Operations for managing users",
					},
				},
			},
		}

		// Add a valid GET operation
		getOp := []byte(`{
			"summary": "Get users",
			"description": "Retrieve a list of users",
			"operationId": "getUsers",
			"responses": {
				"200": {
					"description": "Success",
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"items": {
									"type": "object",
									"properties": {
										"id": {"type": "string"},
										"name": {"type": "string"}
									}
								}
							}
						}
					}
				},
				"400": {
					"$ref": "#/components/responses/BadRequest"
				}
			}
		}`)
		pathItem := spec.API.Paths["/v1/users"]
		pathItem.Get = &runtime.RawExtension{Raw: getOp}
		spec.API.Paths["/v1/users"] = pathItem

		err := validator.validateOpenAPI(spec)
		assert.NoError(t, err)
	})

	t.Run("OpenAPI spec with no operationid", func(t *testing.T) {
		spec := &kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.API{
				BasePath: "/v1/users",
				Paths: map[string]kdexv1alpha1.PathItem{
					"/v1/users": {},
				},
				Schemas: map[string]runtime.RawExtension{
					"User": {
						Raw: []byte(`{
							"type": "object",
							"properties": {
								"id": {"type": "string"},
								"name": {"type": "string"},
								"email": {"type": "string", "format": "email"}
							},
							"required": ["id", "name"]
						}`),
					},
				},
			},
		}

		// Add operation that references the schema
		getOp := []byte(`{
			"summary": "Get users",
			"responses": {
				"200": {
					"description": "Success",
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"items": {
									"$ref": "#/components/schemas/User"
								}
							}
						}
					}
				}
			}
		}`)
		pathItem := spec.API.Paths["/v1/users"]
		pathItem.Get = &runtime.RawExtension{Raw: getOp}
		spec.API.Paths["/v1/users"] = pathItem

		err := validator.validateOpenAPI(spec)
		assert.NotNil(t, err)
		assert.Contains(t, err.Error(), "the `GET` operation does not contain an `operationId`")
	})

	t.Run("OpenAPI spec with schemas", func(t *testing.T) {
		spec := &kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.API{
				BasePath: "/v1/users",
				Paths: map[string]kdexv1alpha1.PathItem{
					"/v1/users": {},
				},
				Schemas: map[string]runtime.RawExtension{
					"User": {
						Raw: []byte(`{
							"type": "object",
							"properties": {
								"id": {"type": "string"},
								"name": {"type": "string"},
								"email": {"type": "string", "format": "email"}
							},
							"required": ["id", "name"]
						}`),
					},
				},
			},
		}

		// Add operation that references the schema
		getOp := []byte(`{
			"summary": "Get users",
			"operationId": "users-get",
			"responses": {
				"200": {
					"description": "Success",
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"items": {
									"$ref": "#/components/schemas/User"
								}
							}
						}
					}
				}
			}
		}`)
		pathItem := spec.API.Paths["/v1/users"]
		pathItem.Get = &runtime.RawExtension{Raw: getOp}
		spec.API.Paths["/v1/users"] = pathItem

		err := validator.validateOpenAPI(spec)
		assert.NoError(t, err)
	})

	t.Run("multiple operations on same path", func(t *testing.T) {
		spec := &kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.API{
				BasePath: "/v1/users",
				Paths: map[string]kdexv1alpha1.PathItem{
					"/v1/users": {},
				},
			},
		}

		// Add GET operation
		getOp := []byte(`{
			"summary": "Get users",
			"operationId": "getUsers",
			"responses": {
				"200": {
					"description": "Success"
				}
			}
		}`)
		pathItem := spec.API.Paths["/v1/users"]
		pathItem.Get = &runtime.RawExtension{Raw: getOp}
		spec.API.Paths["/v1/users"] = pathItem

		// Add POST operation
		postOp := []byte(`{
			"summary": "Create user",
			"operationId": "createUser",
			"requestBody": {
				"required": true,
				"content": {
					"application/json": {
						"schema": {
							"type": "object",
							"properties": {
								"name": {"type": "string"},
								"email": {"type": "string"}
							}
						}
					}
				}
			},
			"responses": {
				"201": {
					"description": "Created"
				}
			}
		}`)
		pathItem = spec.API.Paths["/v1/users"]
		pathItem.Post = &runtime.RawExtension{Raw: postOp}
		spec.API.Paths["/v1/users"] = pathItem

		err := validator.validateOpenAPI(spec)
		assert.NoError(t, err)
	})

	t.Run("path with parameters", func(t *testing.T) {
		spec := &kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.API{
				BasePath: "/v1/users",
				Paths: map[string]kdexv1alpha1.PathItem{
					"/v1/users/{id}": {},
				},
			},
		}

		// Add GET operation with path parameter
		getOp := []byte(`{
			"summary": "Get user by ID",
			"operationId": "getUserById",
			"parameters": [
				{
					"name": "id",
					"in": "path",
					"required": true,
					"schema": {
						"type": "string"
					}
				}
			],
			"responses": {
				"200": {
					"description": "Success"
				},
				"404": {
					"$ref": "#/components/responses/NotFound"
				}
			}
		}`)
		pathItem := spec.API.Paths["/v1/users/{id}"]
		pathItem.Get = &runtime.RawExtension{Raw: getOp}
		spec.API.Paths["/v1/users/{id}"] = pathItem

		err := validator.validateOpenAPI(spec)
		assert.NoError(t, err)
	})

	t.Run("path with security", func(t *testing.T) {
		spec := &kdexv1alpha1.KDexFunctionSpec{
			API: kdexv1alpha1.API{
				BasePath: "/v1/users",
				Paths: map[string]kdexv1alpha1.PathItem{
					"/v1/users/{id}": {},
				},
			},
		}

		// Add GET operation with path parameter
		getOp := []byte(`{
			"summary": "Get user by ID",
			"operationId": "getUserById",
			"parameters": [
				{
					"name": "id",
					"in": "path",
					"required": true,
					"schema": {
						"type": "string"
					}
				}
			],
			"responses": {
				"200": {
					"description": "Success"
				},
				"404": {
					"$ref": "#/components/responses/NotFound"
				}
			},
			"security": [
				{
					"bearer": [
						"pages:read", 
						"pages:write"
					]
				}
			]
		}`)
		pathItem := spec.API.Paths["/v1/users/{id}"]
		pathItem.Get = &runtime.RawExtension{Raw: getOp}
		spec.API.Paths["/v1/users/{id}"] = pathItem

		err := validator.validateOpenAPI(spec)
		assert.NoError(t, err)
	})
}

func TestKDexFunctionValidator_ValidateUpdate(t *testing.T) {
	validator := &KDexFunctionValidator[*kdexv1alpha1.KDexFunction]{}
	ctx := context.Background()

	oldFunction := &kdexv1alpha1.KDexFunction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-function",
			Namespace: "default",
		},
		Spec: kdexv1alpha1.KDexFunctionSpec{
			HostRef: corev1.LocalObjectReference{
				Name: "test-host",
			},
			API: kdexv1alpha1.API{
				BasePath: "/v1/users",
				Paths: map[string]kdexv1alpha1.PathItem{
					"/v1/users": {},
				},
			},
			Metadata: kdexv1alpha1.KDexFunctionMetadata{
				AutoGenerated: true,
			},
		},
	}

	t.Run("valid update", func(t *testing.T) {
		newFunction := oldFunction.DeepCopy()
		pathItem := newFunction.Spec.API.Paths["/v1/users"]
		pathItem.Summary = "Updated summary"
		newFunction.Spec.API.Paths["/v1/users"] = pathItem

		warnings, err := validator.ValidateUpdate(ctx, oldFunction, newFunction)
		assert.NoError(t, err)
		assert.Empty(t, warnings)
	})

	t.Run("update with invalid spec", func(t *testing.T) {
		newFunction := oldFunction.DeepCopy()
		newFunction.Spec.HostRef.Name = "" // Invalid

		warnings, err := validator.ValidateUpdate(ctx, oldFunction, newFunction)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "spec.hostRef.name must not be empty")
		assert.Empty(t, warnings)
	})
}

func TestKDexFunctionValidator_ValidateDelete(t *testing.T) {
	validator := &KDexFunctionValidator[*kdexv1alpha1.KDexFunction]{}
	ctx := context.Background()

	function := &kdexv1alpha1.KDexFunction{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-function",
			Namespace: "default",
		},
	}

	warnings, err := validator.ValidateDelete(ctx, function)
	assert.NoError(t, err)
	assert.Empty(t, warnings)
}

func TestLintOpenAPISpec(t *testing.T) {
	t.Run("valid minimal spec", func(t *testing.T) {
		spec := []byte(`{
			"openapi": "3.0.3",
			"info": {
				"title": "Test API",
				"version": "1.0.0"
			},
			"paths": {
				"/users": {
					"get": {
						"summary": "Get users",
						"responses": {
							"200": {
								"description": "Success"
							}
						}
					}
				}
			}
		}`)

		results, err := linter.LintSpec(spec)
		require.NoError(t, err)

		// Check that we got results (may include warnings)
		assert.NotNil(t, results)
	})

	t.Run("filters OAS3 rules only", func(t *testing.T) {
		spec := []byte(`{
			"openapi": "3.0.3",
			"info": {
				"title": "Test API",
				"version": "1.0.0"
			},
			"paths": {}
		}`)

		results, err := linter.LintSpec(spec)
		require.NoError(t, err)
		assert.NotNil(t, results)
	})
}
